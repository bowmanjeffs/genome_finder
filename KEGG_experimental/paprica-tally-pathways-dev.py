#!/usr/bin/env python
# -*- coding: utf-8 -*-

help_string = """
Created on Sun Oct 11 21:20:57 2015
@author: Jeff Bowman, bowmanjs@ldeo.columbia.edu
paprica is licensed under a Creative Commons Attribution-NonCommercial
4.0 International License.  IF you use any portion of paprica in your
work please cite:
Bowman, Jeff S., and Hugh W. Ducklow. "Microbial Communities Can Be Described
by Metabolic Structure: A General Framework and Application to a Seasonally
Variable, Depth-Stratified Microbial Community from the Coastal West Antarctic
Peninsula." PloS one 10.8 (2015): e0135868.
If your analysis makes specific use of pplacer, Infernal, or pathway-tools
please make sure that you also cite the relevant publications.
REQUIRES:
    Python modules:
        pandas
        numpy
        
CALL AS:
    python paprica_tally_pathways.py [options]
    
OPTIONS:
    -cutoff: The fraction of terminal daughters that need to have a pathway for it
        to be included in an internal node, between 0-1
    -domain: domain of analysis, either bacteria or archaea
    -i: input csv
    -o: prefix for output files
    -ref_dir: name of reference directory
    -override: any known incorrect/correct edge pair replacements to be made in the form:
        "old|new,old|new", note that quotes are necessary
    -omit: a range of edges (e.g. cyanobacteria) that should be omitted in the form:
        start:stop
    -unique: name of unique.seqs.csv file created by paprica-place_it.py.  If none specified,
        unique sequences are not tracked.  To specify a file you must have used the
        -unique T flag in paprica-place_it.py.  This is not the default behavior.
        
This script must be located in the 'paprica' directory as it makes use of relative
paths.
"""

import sys
import os
import pandas as pd
import numpy as np


try:
    paprica_path = os.path.dirname(os.path.abspath(__file__)) + '/' # The location of the actual paprica scripts.
except NameError:
    paprica_path = os.path.dirname(os.path.abspath("__file__")) + '/'

cwd = os.getcwd() + '/'  # The current working directory
    
## Parse command line arguments.
                
command_args = {}

for i,arg in enumerate(sys.argv):
    if arg.startswith('-'):
        arg = arg.strip('-')
        try:
            command_args[arg] = sys.argv[i + 1]
        except IndexError:
            command_args[arg] = ''
        
if 'h' in command_args.keys():
    print help_string
    quit()
        
## If any command line options are specified all need to be specified except
## overrides and omit.

if len(sys.argv) > 2:               
    cutoff = float(command_args['cutoff'])  # The cutoff value used to determine pathways to include for internal nodes.
    domain = command_args['domain']  # The domain (bacteria or archaea) for analysis.
    ref_dir = paprica_path + command_args['ref_dir']  # The complete path to the reference directory being used for analysis.        
    query = command_args['i']
    name = os.path.dirname(query)+'/placeIt/'+os.path.basename(query).rsplit('.taxit.clean.align.csv',1)[0]

    enzyme = command_args['enzyme']
    
    try:
        unique = command_args['unique']
    except KeyError:
        unique = False    
    try:
        overrides = command_args['override']
    except KeyError:
        overrides = ''
    try:
        omit = command_args['omit']
    except KeyError:
        omit = ''
    try:    
        enzyme = command_args['enzyme']
    except KeyError:
        enzyme = 'ko'
    try:
        out = command_args['o']  # The name of the reference package being used.
    except KeyError:
        out = 'outFolder/tallyPathways/'
        print 'Output will be stored in '+cwd+out
    try :
        os.makedirs(out)
    except OSError:
        pass
    print "out = ", out
    print "Tally-pathways output being stored in = ", out

    
#else:
#    query = 'summer.combined_16S.bacteria.tax.clean.align.csv'
#    name = 'summer'
#    cutoff = 0.5  # The cutoff value used to determine pathways to include for internal nodes.
#    domain = 'bacteria'  # The domain (bacteria or archaea) for analysis.
#    ref_dir = paprica_path + 'ref_genome_database'  # The complete path to the reference directory being used for analysis.        
    #omit = '674:818'
    #overrides = '5804|93,4619|4571'
#    overrides = ''
#    omit = ''
#    unique = False
    
## Make sure that ref_dir ends with /.
    
if ref_dir.endswith('/') == False:
    ref_dir = ref_dir + '/'
if out.endswith('/') == False:
    out = out + '/'
    
    
ref_dir_domain = ref_dir + domain + '/'  # The complete path the the domain subdirectory of the reference directory.

## Define a stop function for diagnostic use only.

def stop_here():
    stop = []
    print 'Manually stopped!'
    print stop[1]

## Import csv files generated by paprica_build_core_genomes.

#######



##Create pandas dataframe for new paprica DB with all edges
papricaDB=pd.read_table(ref_dir+domain+'/'+domain+enzyme.upper()+'DB.txt',sep="\t", header=0)


## Create a dictionary of any edges that need replacement.

override_dic = {}

if len(overrides) > 0:
    overrides = overrides.split(',')
    for pair in overrides:
        pair = pair.split('|')
        override_dic[int(pair[0])] = int(pair[1])

## Read in the query csv file generated by paprica_place_it.

query_csv = pd.DataFrame.from_csv(os.path.dirname(query)+'/placeIt/'+os.path.basename(query), header = 0)

## Override bad edges.

for edge in override_dic.keys():
    query_csv.loc[query_csv['edge_num'] == edge, 'edge_num'] = override_dic[edge]
    query_csv.loc[query_csv['edge_num'] == edge, 'post_prob'] = np.NaN

## Tally the number of occurences of each edge in the sample and
## get the mean posterior probability, overlap, and map ratio for each edge.

edge_tally = query_csv.groupby('edge_num').size()
edge_pp = query_csv.groupby('edge_num').post_prob.mean()
edge_map_overlap = query_csv.groupby('edge_num').map_overlap.mean()
edge_map_ratio = query_csv.groupby('edge_num').map_ratio.mean()

## Omit undesired edges.

if len(omit) > 0:
    omit = omit.split(':')
    drop_edges = range(int(omit[0]), int(omit[1]) + 1)
    edge_tally = edge_tally.drop(drop_edges, errors = 'ignore')

## Add the edge tally and mean pp to a new data frame that will hold other
## sample information.

edge_data = pd.DataFrame(index = edge_tally.index)
edge_data['nedge'] = edge_tally
edge_data['post_prob'] = edge_pp
edge_data['map_ratio'] = edge_map_ratio
edge_data['map_overlap'] = edge_map_overlap

## Read in taxa.csv, which holds classification information for each node.

#node_classification = pd.read_csv(ref_dir_domain + 'taxa.csv', index_col = 0)

## Dataframe to hold the number of occurences of pathway in sample, by edge.

sample_ec=pd.DataFrame(index=sorted(papricaDB.edge_num.unique()))
sample_ec=pd.DataFrame() 

for edge in list(edge_tally.index):
    print 'generating data for edge', edge
    
    ## If edge is an internal node...
    
    #if edge in internal_probs.index:
        
    edge_taxid = query_csv[query_csv['edge_num'] == edge].classification[0]
            

    
    edge_ec_n = papricaDB.loc[(papricaDB['edge_num']==edge) & (papricaDB['mean_probs'] >= cutoff),['gene','mean_count']]
    edge_ec_n.columns=['gene',edge]

    sample_ec=pd.merge(sample_ec, edge_ec_n,how='outer',left_index=True,right_on='gene')
    sample_ec.set_index('gene',inplace=True)
	



#if domain != 'eukarya':
#    sample_confidence = sum((edge_data['confidence'] * edge_data['nedge_corrected'])) / edge_data['nedge_corrected'].sum() 



sample_ec_sum = sample_ec.sum(1)
nec = len(sample_ec_sum[sample_ec_sum != 0])
pec = len(sample_ec_sum)

## Write out all the tables.

sample_ec = sample_ec.fillna(0)

edge_data.to_csv(out + '.edge_data.csv')

sample_ec_sum.to_csv(out+ os.path.basename(name) + '.sum_'+enzyme+'.csv')
sample_ec.to_csv(out+ os.path.basename(name) + '.'+enzyme+'.csv')



